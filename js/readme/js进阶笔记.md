# JS数据类型与内存机制

## 为什么关注内存

1. 防止页面占用内存过大，引起客户端卡顿无响应
2. Node.JS使用V8引擎，内存对后端服务的性能至关重要，因为后端服务的持久性，更容易造成内存溢出

## 数据类型和内存空间

* 原始数据类型：String、Number、Boolean、Null、Undefined、Symbol
* 引用数据类型：Object
* 内存空间
  * 栈内存（stack）：原始数据类型直接存储，引用数据类型的时候存储内存地址
  * 堆内存（heap）：开辟空间存储后将内存地址存储到栈内存中

![image-20220210171250004](F:\code\js-demo\js\readme\js进阶笔记.assets\image-20220210171250004.png)

## 垃圾回收机制

垃圾回收：找出不在继续使用的变量，释放其占用内存，按照固定时间间隔周期性执行（不可见）

* 优势：简化程序内存管理代码，降低程序员负担，减少长时间运转而带来的内存泄露问题
* 不足：无法掌控内存、无法强迫回收、干预内存管理

## 垃圾回收策略

* 引用计数（已淘汰）

  * 内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放
  * 缺点：循环引用无法被回收

  

  ```js
  // 正常情况下
  const a = { name: 'xy'} // 引用+1
  a = null // 引用-1 { name: 'xy'} 对象被回收
  // 循环引用无法被回收
  function a(){
      var b = {}
      var c = {}
      b.target = c 
      c.target = b 
  }
  a()
  ```

  

* 标记清除

  * 标记阶段：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”
  * 清除阶段： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除
  * 优点 
    * 不会浪费空间
  * 缺点
    * 清除后会造成内存碎片



```js
function a(){
    // 进入执行环境
    var b = {}
    var c = {}
    b.target = c 
    c.target = b 
}
a() // 退出环境后回收变量
```



## V8内存管理机制

* 限制内存
  * 最初为浏览器设计，不大可能遇到大量你内存的使用场景
  * 防止回收导致线程暂停执行时间过长(50ms)
* V8回收策略：分代回收，将内存分为新生代和老生代
* 采用不同的垃圾回收算法提升垃圾回收的效率
* 新生代
  * 采取停止复制策略，内存分成两块，正在使用的存活对象复制到未使用的内存中，清除正在使用的内存中的所有对象，然后交换内存角色
  * 晋升条件：多次回收未被清除移动到老生代中
* 老生代
  * 采用标记清除法进行垃圾回收
  * 使用标记合并算法整理内存碎片
  * 标记合并：将存活对象移动到一端，清除另一端的内存碎片
